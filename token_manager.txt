
> class ElectroluxTokenManager(TokenManager):
      """Custom token manager that captures token expiration information."""
  
      def __init__(
          self,
          access_token: str,
          refresh_token: str,
          api_key: str,
          on_token_update: Callable[[str, str, str], None] | None = None,
      ):
          """Initialize the custom token manager."""
          super().__init__(
              access_token, refresh_token, api_key, on_token_update=on_token_update
          )
          self._on_token_update_with_expiry: (
              Callable[[str, str, str, int], None] | None
          ) = None
          self._on_auth_error: Callable[[str], Awaitable[None]] | None = None
          self._refresh_lock = asyncio.Lock()
          self._last_refresh_time = 0
          self._expires_at = 0  # Store token expiration timestamp
          self._last_failed_refresh = 0  # Track failed refresh attempts
  
      def set_token_update_callback_with_expiry(
          self, callback: Callable[[str, str, str, int], None]
      ) -> None:
          """Set callback that includes expiration timestamp."""
          self._on_token_update_with_expiry = callback
  
      def set_auth_error_callback(
          self, callback: Callable[[str], Awaitable[None]]
      ) -> None:
          """Set callback for authentication errors."""
          self._on_auth_error = callback
  
      async def refresh_token(self) -> bool:
          """Refresh the access token and capture expiration information."""
          current_time = int(time.time())
          _LOGGER.debug(
              f"TokenManager refresh_token: Starting token refresh process at {current_time}"
          )
  
          # Pre-lock check: avoid acquiring lock if token is still fresh
          if self._expires_at and (self._expires_at - current_time > 900):
              remaining_seconds = self._expires_at - current_time
              _LOGGER.debug(
                  f"TokenManager refresh_token: Token still valid for {remaining_seconds}s (>15 mins), skipping refresh"
              )
              return True
  
          _LOGGER.debug("TokenManager refresh_token: Acquiring refresh lock")
          async with self._refresh_lock:
              _LOGGER.debug("TokenManager refresh_token: Refresh lock acquired")
              # Double-check inside lock: another task may have refreshed while we waited
              current_time = int(time.time())
  
              # Check retry cooldown: don't attempt refresh if we failed recently
              if current_time - self._last_failed_refresh < 60:
                  cooldown_remaining = 60 - (current_time - self._last_failed_refresh)
                  _LOGGER.debug(
                      f"TokenManager refresh_token: Refresh on cooldown, {cooldown_remaining}s remaining after last failure"
                  )
                  return False
  
              # Freshness check: if token is still valid for >15 minutes, skip refresh
              if self._expires_at and (
                  self._expires_at - current_time > 900
              ):  # 15 minutes
                  remaining_seconds = self._expires_at - current_time
                  _LOGGER.debug(
                      f"TokenManager refresh_token: Token still valid for {remaining_seconds}s (>15 mins), skipping refresh"
                  )
                  return True
  
              _LOGGER.debug("TokenManager refresh_token: Preparing refresh request")
              auth_data = self._auth_data
  
              if not auth_data or auth_data.refresh_token is None:
                  _LOGGER.error("TokenManager refresh_token: Refresh token is missing")
                  raise Exception("Missing refresh token")
  
              payload = {REFRESH_TOKEN: auth_data.refresh_token}
              _LOGGER.debug(
                  f"TokenManager refresh_token: Sending refresh request to {TOKEN_REFRESH_URL}"
              )
  
              try:
                  _LOGGER.debug("TokenManager refresh_token: Making HTTP request")
                  data = await request(
                      method=POST, url=TOKEN_REFRESH_URL, json_body=payload
                  )
                  _LOGGER.debug("TokenManager refresh_token: HTTP request successful")
  
                  # Calculate expiration timestamp
                  expires_in = data.get("expiresIn", ACCESS_TOKEN_VALIDITY_SECONDS)
                  expires_at = int(time.time()) + expires_in
                  _LOGGER.debug(
                      f"TokenManager refresh_token: Token expires in {expires_in}s, expires_at: {expires_at}"
                  )
  
                  # Update with new tokens
                  _LOGGER.debug("TokenManager refresh_token: Updating token data")
                  self.update_with_expiry(
                      access_token=data["accessToken"],
                      refresh_token=data["refreshToken"],
                      api_key=auth_data.api_key,
                      expires_at=expires_at,
                  )
  
                  # Update last refresh timestamp
                  self._last_refresh_time = current_time
                  _LOGGER.debug(
                      f"TokenManager refresh_token: Token refresh completed successfully at {current_time}"
                  )
                  return True
  
              except Exception as e:
                  error_msg = str(e).lower()
                  _LOGGER.debug(
                      f"TokenManager refresh_token: Exception during refresh: {e}"
                  )
                  # Check for permanent token errors (401/Invalid Grant)
                  if any(
                      keyword in error_msg
                      for keyword in ["401", "invalid grant", "forbidden"]
                  ):
                      _LOGGER.error(
                          f"TokenManager refresh_token: Permanent token error: {e}"
                      )
                      # Trigger reauthentication immediately
                      if self._on_auth_error:
                          _LOGGER.debug(
                              "TokenManager refresh_token: Triggering auth error callback"
                          )
                          await self._on_auth_error(f"Token refresh failed: {e}")
                      return False
  
                  # For other errors, set cooldown and return False
                  _LOGGER.error(f"TokenManager refresh_token: Token refresh failed: {e}")
                  self._last_failed_refresh = current_time
                  _LOGGER.debug(
                      f"TokenManager refresh_token: Set failed refresh timestamp to {current_time}"
                  )
                  return False
  
      def update_with_expiry(
          self, access_token: str, refresh_token: str, api_key: str, expires_at: int
      ) -> None:
          """Update the authentication data with expiration information."""
          # Call the enhanced callback if available
          if self._on_token_update_with_expiry:
              self._on_token_update_with_expiry(
                  access_token, refresh_token, api_key, expires_at
              )
          # Fall back to standard callback
          elif self._on_token_update:
              self._on_token_update(access_token, refresh_token, api_key)
  
          self._auth_data = AuthData(access_token, refresh_token, api_key)
          self._expires_at = expires_at  # Store expiration timestamp for freshness checks
  
  
  class ElectroluxApiClient:
      """Wrapper for the new Electrolux API client to maintain compatibility."""
  
      def __init__(
          self,
          api_key: str,
          access_token: str,
          refresh_token: str,
          hass: HomeAssistant | None = None,
          config_entry: ConfigEntry | None = None,
      ):
          """Initialize the API client."""
          # Explicitly annotate hass as optional HomeAssistant
          self.hass: HomeAssistant | None = hass
          self.config_entry: ConfigEntry | None = config_entry
          self._auth_failed = False  # Flag to indicate auth failure
          self.coordinator: Any = None  # Reference to coordinator for triggering refresh
          self._token_manager = ElectroluxTokenManager(
              access_token, refresh_token, api_key
          )
          # Set auth error callback to trigger reauthentication
          self._token_manager.set_auth_error_callback(self._trigger_reauth)
          self._client = ApplianceClient(self._token_manager)
          self._token_handler = None  # Track handler
          self._token_logger = None  # Track logger
  
          # Attach token refresh handler to surface token refresh failures as HA issues
          if hass:
              try:
                  self._token_handler = _TokenRefreshHandler(self, hass)
                  self._token_handler.setLevel(logging.ERROR)
                  self._token_logger = logging.getLogger(
                      "electrolux_group_developer_sdk.auth.token_manager"
                  )
                  self._token_logger.addHandler(self._token_handler)
              except Exception:
                  _LOGGER.exception("Failed to attach token refresh logger handler")
  
      def set_token_update_callback(self, callback):
          """Set the callback for token updates."""
          self._token_manager._on_token_update = callback
  
      def set_token_update_callback_with_expiry(self, callback):
          """Set the callback for token updates with expiration information."""
          self._token_manager.set_token_update_callback_with_expiry(callback)
  
      async def _trigger_reauth(self, message: str) -> None:
          """Trigger reauthentication by setting flag, creating issue, and forcing refresh."""
          _LOGGER.debug(f"_trigger_reauth: Triggering reauth due to: {message}")
          self._auth_failed = True
          _LOGGER.debug("_trigger_reauth: Set auth_failed flag to True")
  
          _LOGGER.debug(
              "_trigger_reauth: Reporting token refresh error to create HA issue"
          )
          await self._report_token_refresh_error(message)
  
          # Force an immediate coordinator refresh to trigger reauth
          if self.hass and self.coordinator:
              _LOGGER.debug(
                  "_trigger_reauth: Forcing immediate coordinator refresh to trigger reauth"
              )
              self.hass.loop.call_soon_threadsafe(
                  lambda: asyncio.create_task(self.coordinator.async_refresh())
              )
              _LOGGER.debug("_trigger_reauth: Coordinator refresh task scheduled")
          else:
              _LOGGER.debug(
                  "_trigger_reauth: Cannot force refresh - hass or coordinator not available"
              )
  
      async def _report_token_refresh_error(self, message: str) -> None:
          """Create an HA issue when token refresh fails so user can re-authenticate."""
          _LOGGER.debug(f"_report_token_refresh_error: Called with message: {message}")
          # Avoid passing None to Home Assistant APIs
          if not self.hass:
              _LOGGER.warning(
                  "Token refresh failed but no Home Assistant instance available; skipping issue creation: %s",
                  message,
              )
              return
  
          try:
              _LOGGER.debug("_report_token_refresh_error: Finding config entries")
              # Find the config entry
              entries = self.hass.config_entries.async_entries(DOMAIN)
              if entries:
                  entry = entries[0]
                  issue_id = f"invalid_refresh_token_{entry.entry_id}"
                  _LOGGER.debug(
                      f"_report_token_refresh_error: Using entry {entry.entry_id} for issue ID {issue_id}"
                  )
              else:
                  issue_id = "invalid_refresh_token"
                  _LOGGER.debug(
                      "_report_token_refresh_error: No entries found, using generic issue ID"
                  )
  
              _LOGGER.warning("Token refresh failed: %s. Creating HA issue.", message)
              _LOGGER.debug(
                  f"_report_token_refresh_error: Creating issue with ID {issue_id}"
              )
              issue_registry.async_create_issue(
                  self.hass,
                  DOMAIN,
                  issue_id,
                  is_fixable=True,
                  is_persistent=True,
                  severity=issue_registry.IssueSeverity.CRITICAL,
                  translation_key="invalid_refresh_token",
                  translation_placeholders={"message": message},
              )
              _LOGGER.debug("_report_token_refresh_error: HA issue created successfully")
          except Exception:
              _LOGGER.exception("Failed to create token refresh issue in Home Assistant")
  
      async def _handle_api_call(self, coro):
          """Wrap API calls to handle authentication errors."""
          _LOGGER.debug("_handle_api_call: Starting API call wrapper")
          try:
              result = await coro
              _LOGGER.debug("_handle_api_call: API call completed successfully")
              return result
          except Exception as ex:
              error_msg = str(ex).lower()
              _LOGGER.debug(f"_handle_api_call: Exception caught: {ex}")
              # Check for authentication-related errors
              if any(
                  keyword in error_msg
                  for keyword in [
                      "401",
                      "unauthorized",
                      "invalid grant",
                      "token",
                      "forbidden",
                  ]
              ):
                  # Trigger token refresh handler by logging the error
                  _LOGGER.error("API call failed with authentication error: %s", ex)

